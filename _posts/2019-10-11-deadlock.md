---
layout: post
title: Dead Lock (TWIL)
categories: [db]
tags: [backend, nodejs, database]
---

# ONGOING


### ISSUE

- 쿼리 A, B, C가 있다. 이 세 쿼리 모두 select이다.
 각각의 쿼리는 평균 400ms의 시간이 걸린다.
 이 쿼리를 node.js를 기반인 서버에서 promise 형태로 불러오려고 한다.
 이 때 promise.all로 한번에 불러오면 dead-lock이 생길까?

- 답은 아니오. select 쿼리로는 dead-lock이 생기지 않는다.
    - update, delete, insert는 dead-lock이 생기니 주의
  

### [locks](https://www.letmecompile.com/mysql-innodb-lock-deadlock/) for Inno


#### Row, table level

- Row-level Lock
    - S: Shared lock
        - SELECT를 위한 read lock
        - 한 row에 대해 여러 트랜잭션이 동시에 S-lock을 획득 가능
    - X: Exclusive Lock
        - UPDATE, DELETE를 위한 write lock
        - X-lock이 걸려있으면 다른 트랜잭션이 해당 row에 대해 X, S를 모두 획득 할 수 없음; 대기 상태.

- Table Lock
    - Intention Lock
        - 특정 테이블 안의 "row에 대해서 나중에 어떤 row-level락을 걸 것 이다"라는 의도를 알려주기 위해 
         미리 table-level에 걸어두는 lock
    - `select ... lock in share mode`이 실행되면, 먼져 IS(intention shared lock)이 ***테이블***에 걸리게 된다. 
    이후 row-level의 S가 걸린다.
    - `select ... for update/insert/delete`가 실행되면, 먼저 IX(intention exclusive lock)이 ***테이블***에 걸리게 된다.
    이후 row-level의 X가 걸린다.
    - IS, IX는 여러 트랜잭션에서 동시에 접근 가능; non-block
        - 동일 row에서 S, X를 획득하는 과정에서 동시 접근을 막거나 허용하는 등의 제어를 담당
    - LOCK TABLES, ALTER TABLE, DROP TABLE 트랜잭션 A => IS, IX 트랜잭션 B
        - B 트랜잭션 대기
    - IS, IX 트랜잭션 C => LOCK TABLES, ALTER TABLE, DROP TABLE 트랜잭션 D
        - D 트랜잭션 대기
    - Table-level 한번, row-level 한번; 2단계로 lock을 적용하는 이유
       - Table-lock 트랜잭션 A 중, 트랜잭션 B가 row-lock 하는 것을 막아 줌
      
       
|   | X | IX | S | IS |
|:-:|:-:|:--:|:-:|:--:|
|X|Conflict|Conflict|Conflict|Conflict|
|IX|Conflict|Compatible|Conflict|Compatible|
|S|Conflict|Conflict|Compatible|Compatible|
|IS|Conflict|Compatible|Compatible|Compatible|
    
    
### [Dead Lock 발생 조건](https://jwprogramming.tistory.com/12)


다음 4가지 조건이 아니면 Dead lock을 해결할 수 있다. 즉, 4 조건은 해결 불가능

#### 상호 배제 원칙 위반

자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

- P0은 R0을 점유
    - 점유 중에는 어느 프로세스도 R0을 사용할 수 없음

#### 점유 대기 원칙 위반

최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을
추가로 점유하기 위해서 대기하는 프로세스가 있어야한다.

- P0이 R0을 점유
- P1이 R1을 점유
- P0은 R1을 점유하고 싶음
    - 그러기 위해서는 대기하는 P2가 존재해야 함

#### 비선점 원칙 위반

다른 프로세스에 할당된 자원은 사용이 끝날 대까지 강제로 빼앗을 수 없어야 한다.

- P0이 R0을 점유
- P1이 R1을 점유
- P0은 R1을 점유하고 싶음
    - 그러기 위해서는 대기하는 P2가 존재해야 함
    - 하지만 아직 P1이 R1을 사용 중이라서 R1을 빼앗아 점유할 수 없음
- P1은 R1의 사용을 종료함
- 이제 R1은 자유가 되었고 다른 프로세스가 점유할 수 있음

#### 순환 대기 상태

프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 
P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 
Pn은 P0가 점유한 자원을 요구해야 한다.


### [예방, 회피, 탐지, 회복](https://jwprogramming.tistory.com/12)

  
  
  
  
  
  
  
  
  
  
### 기타 링크(출처)

-  https://kuaaan.tistory.com/100 
- https://nexondbteam.tistory.com/66
  

 
